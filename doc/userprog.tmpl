             +-------------------------+
             |         OS 211          |
             |  TASK 2: USER PROGRAMS  |
             |     DESIGN DOCUMENT     |
             +-------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Rob Wakefield <rgw20@ic.ac.uk>
Nada Struharova <email@domain.example>
Harrison Barker <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, or notes for the
>> markers, please give them here.

>> Please cite any offline or online sources you consulted while preparing your 
>> submission, other than the Pintos documentation, course text, lecture notes 
>> and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: (1 mark)
>> Copy here the declaration of each new or changed `struct' or `struct' member, 
>> global or static variable, `typedef', or enumeration. 
>> Identify the purpose of each in roughly 25 words.

---- ALGORITHMS ----

>> A2: (2 marks)
>> How does your argument parsing code avoid overflowing the user's stack page?
>> What are the efficiency considerations of your approach?

The total size of all the arguments passed and the number of arguments are checked in order to make sure that they would fit in a single page after the pointers and other necessary stack values.

As each argument is parsed, it is calculated how much space on the stack it will take. This is added to a total argv size variable. As each argv needs a corresponding pointer on the stack, the equation: total_arg_size + argc + 4 < PGSIZE can be used to determine whether there will be enough space in the user page to store this stack. If there is not, the process terminates, freeing the user page.

The approach we have taken does include some extra calculation during argument passing but it ensures that a page fault exception can never occur.  We could have waited for a page fault however this would produce the error after the stack had filled the page which doesnâ€™t allow for fast and efficient freeing of garbage memory for other processes.

---- RATIONALE ----

>> A3: (2 marks)
>> Pintos does not implement strtok() because it is not thread safe. 
>> Explain the problem with strtok() and how strtok_r() avoids this issue.

>> A4: (3 marks)
>> In Pintos, the kernel separates commands into an executable name and arguments. 
>> In Unix-like systems, the shell does this separation. 
>> Identify three advantages of the Unix approach.

                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: (6 marks) 
>> Copy here the declaration of each new or changed `struct' or `struct' member, 
>> global or static variable, `typedef', or enumeration. 
>> Identify the purpose of each in roughly 25 words.

---- ALGORITHMS ----

>> B2: (2 marks)
>> Describe how your code ensures safe memory access of user provided data from
>> within the kernel. 

Every pointer in a syscall is checked using pagedir_get_page() and is_user_vaddr() to ensure that it is a pointer into user allocated memory before it can be dereferenced. For memory access in the user program, if an invalid address is attempted to be accessed then the page fault interrupt handler is called and the program is terminated.

>> B3: (3 marks)
>> Suppose that we choose to verify user provided pointers by validating them 
>> before use (i.e. using the first method described in the spec).
>> What is the least and the greatest possible number of inspections of the page
>> table (e.g. calls to pagedir_get_page()) that would need to be made in the 
>> following cases?
>> a) A system call that passes the kernel a pointer to 10 bytes of user data.

1. Check pointer has been passed as argument
2. Check pointer points to valid user memory
3. Check pointer + 10 points to valid user memory
So 3 calls.

>> b) A system call that passes the kernel a pointer to a full page 
>>    (4,096 bytes) of user data.

1. Check pointer has been passed as argument
2. Check pointer points to valid user memory
3. Check pointer + PGSIZE points to valid user memory
So 3 calls.

>> c) A system call that passes the kernel a pointer to 4 full pages 
>>    (16,384 bytes) of user data.

1. Check pointer has been passed as argument
2. Check pointer points to valid user memory
3. Check pointer every PGSIZE addresses until pointer + 4 * PGSIZE points to valid user memory
So 6 calls.

>> You must briefly explain the checking tactic you would use and how it applies 
>> to each case to generate your answers.

>> B4: (2 marks)
>> When an error is detected during a system call handler, how do you ensure 
>> that all temporarily allocated resources (locks, buffers, etc.) are freed?

If an error occurs during a system call, the system call does not return immediately if temporarily allocated resources exist, instead the error code will be stored in the interrupt frames eax register, and the code frees the allocated resources before returning.

For example, for a syscall and a function which performs an operation that could fail:

syscall () {
  intr_frame f;
  lock_acquire (&file_lock);
  f->eax = succeed_or_fail ();
  lock_release (&file_lock);
}

>> B5: (8 marks)
>> Describe your implementation of the "wait" system call and how it interacts 
>> with process termination for both the parent and child.

---- SYNCHRONIZATION ----

>> B6: (2 marks)
>> The "exec" system call returns -1 if loading the new executable fails, so it 
>> cannot return before the new executable has completed loading. 
>> How does your code ensure this? 
>> How is the load success/failure status passed back to the thread that calls 
>> "exec"?

>> B7: (5 marks)
>> Consider parent process P with child process C. 
>> How do you ensure proper synchronization and avoid race conditions when: 
>>   i) P calls wait(C) before C exits?
>>  ii) P calls wait(C) after C exits?
>> iii) P terminates, without waiting, before C exits?
>>  iv) P terminates, without waiting, after C exits?
>> Additionally, how do you ensure that all resources are freed regardless of 
>> the above case? 

---- RATIONALE ----

>> B8: (2 marks)
>> Why did you choose to implement safe access of user memory from the kernel in 
>> the way that you did?

>> B9: (2 marks)
>> What advantages and disadvantages can you see to your design for file 
>> descriptors?
