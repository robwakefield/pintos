            +--------------------------+
            |          OS 211          |
            |  TASK 3: VIRTUAL MEMORY  |
            |      DESIGN DOCUMENT     |
            +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Rob Wakefield <rgw20@ic.ac.uk>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, or notes for the
>> markers, please give them here.

>> Please cite any offline or online sources you consulted while preparing your 
>> submission, other than the Pintos documentation, course text, lecture notes 
>> and course staff.

            PAGE TABLE/FRAME MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: (2 marks)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> supplemental page table and frame table. 
>> Identify the purpose of each in roughly 25 words.

/* enum to track the status of the page in the page table */
enum page_status
{
  ALL_ZERO,       /* Zeroed page (new page). */
  IN_FRAME,       /* Frame allocated to page. */
  SWAPPED,        /* Page is swapped (in swap slot). */
  FILE,           /* Page needs to be loaded from file */
  MMAPPED         /* Page is mmapped */
};

/* Virtual page stored in the SPTE */
struct page
{
  void *addr;                 /* User virtual address. */
  bool writable;             /* Read-only page? */
  bool dirty;
  struct thread *owner;      /* Owning thread. */

  enum page_status status;

  struct hash_elem hash_elem;
  struct list_elem list_elem;

  /* Set only in owning process context with frame->frame_lock held.
  Cleared only with scan_lock and frame->frame_lock held. */
  void *kpage;   

  struct file *file;          /* File. */
  off_t offset;               /* Offset in file. */
  uint32_t read_bytes;           /* Bytes to read/write, 1...PGSIZE. */
  uint32_t zero_bytes;
  
  size_t swap_slot;
};

/* Stores the necessary information needed for each entry in the frame table */
struct frame_entry
{
  void *frame_address;
  void *upage;

  struct list pages;
  struct lock pages_lock;

  bool pinned;
  struct thread *owner;
  struct hash_elem hash_elem;
  struct list_elem list_elem;
};

---- ALGORITHMS ----

>> A2: (2 marks) 
>> Describe your code for finding the frame (if any) or other location that 
>> contains the data of a given page.

If a page has already been installed then the frame is mapped using the functions in pagedir.c. Otherwise the page is not loaded and a page fault will occur. To load the page, we have a field in our page struct that stores the status of that page (IN_FRAME, MMAPPED, SWAPPED, ...), this field is checked and the frame address is found based on the status. If the page is IN_FRAME, then the address is simply the kpage field of the page. If the page is MMAPPED or a FILE then the page is loaded from the file into a frame and the address of that frame is stored in the pages kpage field. If the page status is SWAPPED then the page is swapped back in and the frame address stored in the kpage field. In all cases but IN_FRAME, the page is installed to the pagedir using install_page(). 

>> A3: (2 marks)
>> How have you implemented sharing of read only pages?

When a read only page is attempted to be loaded, we first check whether we can share with another page. The page table of the current thread is searched for a age which contains the same data needed by the page we want to load in (the file and offset). If this isn't found then the page is loaded in like normal from the file. However, if a matching page is found we copy all the values stored in that page such as the address of the underlying frame (if any) and whether or not the page has been swapped or not. So now the page points to the correct frame and has the correct status so we call the function to load the page with this new information. If the page's status is now IN_FRAME then we are done and the page points to that frame. If the page's status is SWAPPED then the frame is swapped back in to the frame table.

---- SYNCHRONIZATION ----

>> A4: (2 marks) 
>> When two user processes both need a new frame at the same time, how are 
>> races avoided? 
>> You should consider both when there are and are not free frames 
>> available in memory.

Lock on the frame table.

---- RATIONALE ----

>> A5: (2 marks)
>> Why did you choose the data structure(s) that you did for representing the
>> supplemental page table and frame table?

Hash.

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: (1 mark)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> swap table.  
>> Identify the purpose of each in roughly 25 words.

/* Same struct as in A1 with the fields used for paging from a file highlighted */
struct page
{
  ...
  struct file *file;          /* File. */
  off_t offset;               /* Offset in file. */
  uint32_t read_bytes;        /* Bytes to read/write, 1...PGSIZE. */
  uint32_t zero_bytes;
  ...
};

---- ALGORITHMS ----

>> B2: (2 marks)
>> When a frame is required but none is free, some frame must be evicted.
>> Describe your code for choosing a frame to evict.

>> B3: (2 marks)
>> When a process P obtains a frame that was previously used by a process Q,
>> how do you adjust the page directory of process Q (and any other data 
>> structures) to reflect the frame Q no longer has?

---- SYNCHRONIZATION ----

>> B4: (2 marks)
>> Explain how your synchronization design prevents deadlock.  
>> (You may want to refer to the necessary conditions for deadlock.)

>> B5: (2 marks)
>> A page fault in process P can cause another process Q's frame to be evicted.
>> How do you ensure that Q cannot access or modify the page during the 
>> eviction process?

>> B6: (2 marks)
>> A page fault in process P can cause another process Q's frame to be evicted.
>> How do you avoid a race between P evicting Q's frame and Q faulting the page
>> back in?

>> B7: (2 marks)
>> Explain how you handle access to user pages that are not present when a
>> system call is made.

When we check that a pointer in a system call is valid, we check whether we can read or write to that location using the provided functions get_user and put_user from Task 2. These will cause a page fault if the user pages are not present and if this is the case the page fault handler will find the page containing the faulting address in the thread's page table. It then tries to load this page in before returning, allowing get_user/put_user to run again and if they do not page fault the second time, the address must be valid. So when the pointers are used during the syscall the page will be present.

---- RATIONALE ----

>> B8: (2 marks)
>> There is an obvious trade-off between parallelism and the complexity of your
>> synchronisation methods. 
>> Explain where your design falls along this continuum and why you chose to 
>> design it this way.

We chose to implement course grained locking of our frame table. This was to ensure that we did not miss any complex race conditions that could arise form a finer grained approach. This will lead to a decrease in performance when many processes are accessing the frame table at once, but given the limitation of the pintos os we thought that this was a reassonable trade off. We chose not to lock the page table as there will be no race conditions due to the page table only ever being accessed by the thread which owns it. Overall we chose to provide a very safe synchronisation strategy even though it may not be the most parallel in order to best suit the pintos os limitations and maintain solid memory safety.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: (1 mark)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> file mapping table.  
>> Identify the purpose of each in roughly 25 words.

struct mmapTable{
  struct mmapProc *header;
  int tabNum;
  struct mmapTable *nextTable;
  struct mmapTable *prevTable;
  int free;
  void* table[MM_SIZE];
};

Stores pointers to the start of MMAP pages with the mapID acting as the index. The table expands itself as MMaps are opened in the same way as the FDTables do. 

struct mmapProc{
    int tid;
    struct list_elem elem;
    struct mmapTable *mmapTable;
};

The headers for the mapId tables. Links to the main table for the process and can be found in the list by matching to the tid.

static struct list file_list; 

A list of the mapId tables
---- ALGORITHMS ----

>> C2: (3 marks)
>> Explain how you determine whether a new file mapping overlaps with any 
>> existing segment and how you handle such a case.

Firstly we check if the address given lies inside the area set aside for the initial stack and return -1 if this is the case.
Then we try to open each page in turn, first checking if the page is already allocated using page_lookup to check whether the address corresponds to an existing entry. 
If a page is already allocated then any pages that had previously been allocated for the MMAP are deallocated and -1 is returned.
If all the pages are successfully allocated then it is stored in the MapId table and the corresponding MapId is returned.

---- RATIONALE ----

>> C3: (1 mark)
>> Mappings created with "mmap" have similar semantics to those of data 
>> demand-paged from executables. 
>> How does your code-base take advantage of this?

Once pages are allocated, data from files are loaded and evicted in the same way since this behaviour is the same between them. 
