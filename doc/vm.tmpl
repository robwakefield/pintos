            +--------------------------+
            |          OS 211          |
            |  TASK 3: VIRTUAL MEMORY  |
            |      DESIGN DOCUMENT     |
            +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Rob Wakefield <rgw20@ic.ac.uk>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, or notes for the
>> markers, please give them here.

>> Please cite any offline or online sources you consulted while preparing your 
>> submission, other than the Pintos documentation, course text, lecture notes 
>> and course staff.

            PAGE TABLE/FRAME MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: (2 marks)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> supplemental page table and frame table. 
>> Identify the purpose of each in roughly 25 words.

---- ALGORITHMS ----

>> A2: (2 marks) 
>> Describe your code for finding the frame (if any) or other location that 
>> contains the data of a given page.

>> A3: (2 marks)
>> How have you implemented sharing of read only pages?

When a read only page is attempted to be loaded, we first check whether we can share with another page. The page table of the current thread is searched for a age which contains the same data needed by the page we want to load in (the file and offset). If this isn't found then the page is loaded in like normal from the file. However, if a matching page is found we copy all the values stored in that page such as the address of the underlying frame (if any) and whether or not the page has been swapped or not. So now the page points to the correct frame and has the correct status so we call the function to load the page with this new information. If the page's status is now IN_FRAME then we are done and the page points to that frame. If the page's status is SWAPPED then the frame is swapped back in to the frame table.

---- SYNCHRONIZATION ----

>> A4: (2 marks) 
>> When two user processes both need a new frame at the same time, how are 
>> races avoided? 
>> You should consider both when there are and are not free frames 
>> available in memory.

Lock on the frame table.

---- RATIONALE ----

>> A5: (2 marks)
>> Why did you choose the data structure(s) that you did for representing the
>> supplemental page table and frame table?

Hash.

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: (1 mark)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> swap table.  
>> Identify the purpose of each in roughly 25 words.

---- ALGORITHMS ----

>> B2: (2 marks)
>> When a frame is required but none is free, some frame must be evicted.
>> Describe your code for choosing a frame to evict.

>> B3: (2 marks)
>> When a process P obtains a frame that was previously used by a process Q,
>> how do you adjust the page directory of process Q (and any other data 
>> structures) to reflect the frame Q no longer has?



---- SYNCHRONIZATION ----

>> B4: (2 marks)
>> Explain how your synchronization design prevents deadlock.  
>> (You may want to refer to the necessary conditions for deadlock.)

>> B5: (2 marks)
>> A page fault in process P can cause another process Q's frame to be evicted.
>> How do you ensure that Q cannot access or modify the page during the 
>> eviction process?

>> B6: (2 marks)
>> A page fault in process P can cause another process Q's frame to be evicted.
>> How do you avoid a race between P evicting Q's frame and Q faulting the page
>> back in?

>> B7: (2 marks)
>> Explain how you handle access to user pages that are not present when a
>> system call is made.

When we check that a pointer in a system call is valid, we check whether we can read or write to that location using the provided functions get_user and put_user from Task 2. These will cause a page fault if the user pages are not present and if this is the case the page fault handler will find the page containing the faulting address in the thread's page table. It then tries to load this page in before returning, allowing get_user/put_user to run again and if they do not page fault the second time, the address must be valid. So when the pointers are used during the syscall the page will be present.

---- RATIONALE ----

>> B8: (2 marks)
>> There is an obvious trade-off between parallelism and the complexity of your
>> synchronisation methods. 
>> Explain where your design falls along this continuum and why you chose to 
>> design it this way.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: (1 mark)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> file mapping table.  
>> Identify the purpose of each in roughly 25 words.

---- ALGORITHMS ----

>> C2: (3 marks)
>> Explain how you determine whether a new file mapping overlaps with any 
>> existing segment and how you handle such a case.

---- RATIONALE ----

>> C3: (1 mark)
>> Mappings created with "mmap" have similar semantics to those of data 
>> demand-paged from executables. 
>> How does your code-base take advantage of this?
